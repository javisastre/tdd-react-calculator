"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const CSSStyleDeclarationPropertyManager_1 = __importDefault(require("./CSSStyleDeclarationPropertyManager"));
const NodeTypeEnum_1 = __importDefault(require("../../../nodes/node/NodeTypeEnum"));
const CSSRuleTypeEnum_1 = __importDefault(require("../../CSSRuleTypeEnum"));
const CSSStyleDeclarationElementDefaultCSS_1 = __importDefault(require("./CSSStyleDeclarationElementDefaultCSS"));
const CSSStyleDeclarationElementInheritedProperties_1 = __importDefault(require("./CSSStyleDeclarationElementInheritedProperties"));
const CSSStyleDeclarationCSSParser_1 = __importDefault(require("./CSSStyleDeclarationCSSParser"));
const CSS_VARIABLE_REGEXP = /var\( *(--[^) ]+)\)/g;
/**
 * CSS Style Declaration utility
 */
class CSSStyleDeclarationElementStyle {
    /**
     * Constructor.
     *
     * @param element Element.
     * @param [computed] Computed.
     */
    constructor(element, computed = false) {
        this.cache = {};
        this.element = element;
        this.computed = computed;
    }
    /**
     * Returns element style properties.
     *
     * @returns Element style properties.
     */
    getElementStyle() {
        if (this.computed) {
            return this.getComputedElementStyle();
        }
        const cssText = this.element['_attributes']['style']?.value;
        if (cssText) {
            if (this.cache[cssText]) {
                return this.cache[cssText];
            }
            this.cache[cssText] = new CSSStyleDeclarationPropertyManager_1.default({ cssText });
            return this.cache[cssText];
        }
        return new CSSStyleDeclarationPropertyManager_1.default();
    }
    /**
     * Returns style sheets.
     *
     * @param element Element.
     * @returns Style sheets.
     */
    getComputedElementStyle() {
        const documentElements = [];
        const parentElements = [];
        let styleAndElement = {
            element: this.element,
            cssText: ''
        };
        let shadowRootElements = [];
        if (!this.element.isConnected) {
            return new CSSStyleDeclarationPropertyManager_1.default();
        }
        // Walks through all parent elements and stores them in an array with element and matching CSS text.
        while (styleAndElement.element) {
            if (styleAndElement.element.nodeType === NodeTypeEnum_1.default.elementNode) {
                const rootNode = styleAndElement.element.getRootNode();
                if (rootNode.nodeType === NodeTypeEnum_1.default.documentNode) {
                    documentElements.unshift(styleAndElement);
                }
                else {
                    shadowRootElements.unshift(styleAndElement);
                }
                parentElements.unshift(styleAndElement);
            }
            if (styleAndElement.element === this.element.ownerDocument) {
                const styleSheets = (this.element.ownerDocument.querySelectorAll('style,link[rel="stylesheet"]'));
                for (const styleSheet of styleSheets) {
                    const sheet = styleSheet.sheet;
                    if (sheet) {
                        this.parseCSSRules({
                            elements: documentElements,
                            cssRules: sheet.cssRules
                        });
                    }
                }
                styleAndElement = { element: null, cssText: '' };
            }
            else if (styleAndElement.element.host) {
                const styleSheets = (styleAndElement.element.querySelectorAll('style,link[rel="stylesheet"]'));
                styleAndElement = {
                    element: styleAndElement.element.host,
                    cssText: ''
                };
                for (const styleSheet of styleSheets) {
                    const sheet = styleSheet.sheet;
                    if (sheet) {
                        this.parseCSSRules({
                            elements: shadowRootElements,
                            cssRules: sheet.cssRules,
                            hostElement: styleAndElement
                        });
                    }
                }
                shadowRootElements = [];
            }
            else {
                styleAndElement = { element: styleAndElement.element.parentNode, cssText: '' };
            }
        }
        // Concatenates all parent element CSS to one string.
        const targetElement = parentElements[parentElements.length - 1];
        let inheritedCSSText = CSSStyleDeclarationElementDefaultCSS_1.default.default;
        for (const parentElement of parentElements) {
            if (parentElement !== targetElement) {
                inheritedCSSText +=
                    (CSSStyleDeclarationElementDefaultCSS_1.default[parentElement.element.tagName] || '') +
                        parentElement.cssText +
                        (parentElement.element['_attributes']['style']?.value || '');
            }
        }
        const cssVariables = {};
        const properties = {};
        const targetCSSText = (CSSStyleDeclarationElementDefaultCSS_1.default[targetElement.element.tagName] || '') +
            targetElement.cssText +
            (targetElement.element['_attributes']['style']?.value || '');
        const combinedCSSText = inheritedCSSText + targetCSSText;
        if (this.cache[combinedCSSText]) {
            return this.cache[combinedCSSText];
        }
        // Parses the parent element CSS and stores CSS variables and inherited properties.
        CSSStyleDeclarationCSSParser_1.default.parse(inheritedCSSText, (name, value, important) => {
            if (name.startsWith('--')) {
                const cssValue = this.getCSSValue(value, cssVariables);
                if (cssValue) {
                    cssVariables[name] = cssValue;
                }
                return;
            }
            if (CSSStyleDeclarationElementInheritedProperties_1.default[name]) {
                const cssValue = this.getCSSValue(value, cssVariables);
                if (cssValue && (!properties[name]?.important || important)) {
                    properties[name] = {
                        value: cssValue,
                        important
                    };
                }
            }
        });
        // Parses the target element CSS.
        CSSStyleDeclarationCSSParser_1.default.parse(targetCSSText, (name, value, important) => {
            if (name.startsWith('--')) {
                const cssValue = this.getCSSValue(value, cssVariables);
                if (cssValue && (!properties[name]?.important || important)) {
                    cssVariables[name] = cssValue;
                    properties[name] = {
                        value,
                        important
                    };
                }
            }
            else {
                const cssValue = this.getCSSValue(value, cssVariables);
                if (cssValue && (!properties[name]?.important || important)) {
                    properties[name] = {
                        value: cssValue,
                        important
                    };
                }
            }
        });
        const propertyManager = new CSSStyleDeclarationPropertyManager_1.default();
        for (const name of Object.keys(properties)) {
            propertyManager.set(name, properties[name].value, properties[name].important);
        }
        this.cache[combinedCSSText] = propertyManager;
        return propertyManager;
    }
    /**
     * Applies CSS text to elements.
     *
     * @param options Options.
     * @param options.elements Elements.
     * @param options.cssRules CSS rules.
     * @param [options.hostElement] Host element.
     * @param [options.hostElement.element] Element.
     * @param [options.hostElement.cssText] CSS text.
     */
    parseCSSRules(options) {
        if (!options.elements.length) {
            return;
        }
        const defaultView = options.elements[0].element.ownerDocument.defaultView;
        for (const rule of options.cssRules) {
            if (rule.type === CSSRuleTypeEnum_1.default.styleRule) {
                const selectorText = rule.selectorText;
                if (selectorText) {
                    if (selectorText.startsWith(':host')) {
                        if (options.hostElement) {
                            options.hostElement.cssText += rule._cssText;
                        }
                    }
                    else {
                        for (const element of options.elements) {
                            if (element.element.matches(selectorText)) {
                                element.cssText += rule._cssText;
                            }
                        }
                    }
                }
            }
            else if (rule.type === CSSRuleTypeEnum_1.default.mediaRule &&
                defaultView.matchMedia(rule.conditionalText).matches) {
                this.parseCSSRules({
                    elements: options.elements,
                    cssRules: rule.cssRules,
                    hostElement: options.hostElement
                });
            }
        }
    }
    /**
     * Returns CSS value.
     *
     * @param value Value.
     * @param cssVariables CSS variables.
     * @returns CSS value.
     */
    getCSSValue(value, cssVariables) {
        const regexp = new RegExp(CSS_VARIABLE_REGEXP);
        let newValue = value;
        let match;
        while ((match = regexp.exec(value)) !== null) {
            const cssVariableValue = cssVariables[match[1]];
            if (!cssVariableValue) {
                return null;
            }
            newValue = newValue.replace(match[0], cssVariableValue);
        }
        return newValue;
    }
}
exports.default = CSSStyleDeclarationElementStyle;
//# sourceMappingURL=CSSStyleDeclarationElementStyle.js.map